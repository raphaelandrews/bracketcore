{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "double-elimination",
  "title": "Double Elimination",
  "description": "A double elimination bracket using CSS Grid for precise alignment.",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "match-card"
  ],
  "files": [
    {
      "path": "registry/bracketcore/double-elimination.tsx",
      "content": "import type { DoubleEliminationBracket, Match, Round } from \"./bracket-types\";\nimport { MatchCard } from \"./match-card\";\nimport { cn } from \"./cn\";\n\nexport interface DoubleEliminationProps {\n  bracket: DoubleEliminationBracket;\n  className?: string;\n  onMatchClick?: (match: Match) => void;\n  /**\n   * The LB round index that the first UB round should align with.\n   * Useful when LB starts \"earlier\" (has preliminary rounds) than UB.\n   * Default: 0.\n   */\n  ubAlignToLBRound?: number;\n  connectorStyle?: \"default\" | \"simple\";\n}\n\n// Each match occupies 2 grid rows (one per team row).\n// Row computation builds bottom-up: round 1 matches are evenly spaced,\n// subsequent rounds are centered between their two feeder matches.\n\ninterface MatchPos {\n  topRow: number;\n  botRow: number;\n}\n\nfunction computeBracketRows(\n  rounds: Round[],\n  startRow: number,\n  connectorTypes: Array<\"merge\" | \"straight\">,\n): MatchPos[][] {\n  const result: MatchPos[][] = [];\n\n  // Round 1: matches stacked sequentially\n  const r0: MatchPos[] = [];\n  for (let i = 0; i < rounds[0]!.matches.length; i++) {\n    const top = startRow + i * 2;\n    r0.push({ topRow: top, botRow: top + 1 });\n  }\n  result.push(r0);\n\n  // Subsequent rounds\n  for (let r = 1; r < rounds.length; r++) {\n    const prev = result[r - 1]!;\n    const curr: MatchPos[] = [];\n    const connType = connectorTypes[r - 1];\n\n    if (connType === \"merge\") {\n      // 2→1: center between pairs\n      for (let i = 0; i < rounds[r]!.matches.length; i++) {\n        const feederA = prev[i * 2]!;\n        const feederB = prev[i * 2 + 1]!;\n        const center = Math.floor((feederA.topRow + feederB.botRow) / 2);\n        curr.push({ topRow: center, botRow: center + 1 });\n      }\n    } else {\n      // straight: same rows as previous round\n      for (let i = 0; i < rounds[r]!.matches.length; i++) {\n        curr.push({ ...prev[i]! });\n      }\n    }\n\n    result.push(curr);\n  }\n\n  return result;\n}\n\nfunction computeConnectorTypes(rounds: Round[]): Array<\"merge\" | \"straight\"> {\n  const types: Array<\"merge\" | \"straight\"> = [];\n  for (let i = 0; i < rounds.length - 1; i++) {\n    types.push(rounds[i + 1]!.matches.length < rounds[i]!.matches.length ? \"merge\" : \"straight\");\n  }\n  return types;\n}\n\nexport function DoubleElimination({\n  bracket,\n  className,\n  onMatchClick,\n  ubAlignToLBRound = 0,\n  connectorStyle = \"default\",\n}: DoubleEliminationProps) {\n  const { upper, lower, grandFinal } = bracket;\n\n  // LB dictates the specific columns because it has more rounds (usually).\n  // LB Rounds: 0, 1, 2, ...\n  // Grid Columns:\n  // Col 0: LB R0 Match\n  // Col 1: LB R0->R1 Connector\n  // Col 2: LB R1 Match\n  // Col 3: LB R1->R2 Connector\n  // ...\n  // Grid Col for LB Round i = i * 2 + 1 (1-based grid)\n\n  const getLBCol = (rIdx: number) => 1 + rIdx * 2;\n\n  // UB Alignment:\n  // UB R0 aligns with LB R0 -> Col 1.\n  // UB Final (last round) aligns with LB Final (last round).\n  // UB Intermediate rounds are interpolated.\n\n  const ubCount = upper.length;\n  const lbCount = lower.length;\n\n\n  // Function to map UB round index to Grid Column\n  const getUBCol = (rIdx: number) => {\n    const startInd = ubAlignToLBRound;\n    const endInd = lbCount - 1;\n\n    // Safety: if counts are small\n    if (lbCount === 0) return 1 + rIdx * 2;\n\n    if (rIdx === 0) return getLBCol(startInd);\n    if (rIdx === ubCount - 1) return getLBCol(endInd);\n\n    // Interpolate indices between startInd and endInd\n\n    const step = (endInd - startInd) / (ubCount - 1);\n    const targetLBIdx = Math.round(startInd + rIdx * step);\n    return getLBCol(targetLBIdx);\n  };\n\n  const ubMatchCols: number[] = [];\n  const ubConnCols: number[] = []; // Column where the connector STARTS\n  const ubConnSpans: number[] = [];\n\n  for (let i = 0; i < ubCount; i++) {\n    ubMatchCols.push(getUBCol(i));\n    if (i < ubCount - 1) {\n      // Connector exists between current Round and Next Round\n      const startCol = getUBCol(i) + 1; // Start right after current match\n      const endCol = getUBCol(i + 1);   // End right before next match\n      ubConnCols.push(startCol);\n      ubConnSpans.push(endCol - startCol);\n    }\n  }\n\n  const lbMatchCols: number[] = [];\n  const lbConnCols: number[] = [];\n\n  for (let i = 0; i < lbCount; i++) {\n    lbMatchCols.push(getLBCol(i));\n    if (i < lbCount - 1) {\n      lbConnCols.push(getLBCol(i) + 1);\n    }\n  }\n\n  // Grand Final Column\n  const lastBracketCol = Math.max(\n    lbMatchCols[lbMatchCols.length - 1] ?? 0,\n    ubMatchCols[ubMatchCols.length - 1] ?? 0,\n  );\n\n  const gfConnCol = grandFinal ? lastBracketCol + 1 : 0;\n  const gfMatchCol = grandFinal ? lastBracketCol + 2 : 0;\n  const totalCols = grandFinal ? gfMatchCol : lastBracketCol;\n\n  // --- Connector types ---\n  // UB always matches\n\n  const lbConnTypes = computeConnectorTypes(lower);\n\n  // --- Row computation ---\n  const headerRow = 1;\n  const ubStartRow = 2;\n  const ubRows = computeBracketRows(upper, ubStartRow, Array(upper.length - 1).fill(\"merge\"));\n\n  // Total rows used by UB\n  const ubMaxRow =\n    ubRows[0]!.length > 0 ? ubRows[0]![ubRows[0]!.length - 1]!.botRow : ubStartRow + 1;\n\n  const gapRows = 2;\n  const lbHeaderRow = ubMaxRow + gapRows + 1;\n  const lbStartRow = lbHeaderRow + 1;\n  const lbRows = computeBracketRows(lower, lbStartRow, lbConnTypes);\n\n  // Total rows used by LB\n  const lbMaxRow =\n    lbRows[0]!.length > 0 ? lbRows[0]![lbRows[0]!.length - 1]!.botRow : lbStartRow + 1;\n\n  const totalRows = lbMaxRow + 1;\n\n  // Build grid-template-columns\n  const colDefs: string[] = [];\n  for (let c = 1; c <= totalCols; c++) {\n    const isMatchCol = ubMatchCols.includes(c) || lbMatchCols.includes(c) || c === gfMatchCol;\n\n    if (isMatchCol) {\n      colDefs.push(\"var(--bracket-match-width, 11rem)\");\n    } else {\n      colDefs.push(\"var(--bracket-round-gap, 3rem)\");\n    }\n  }\n\n  // Build grid-template-rows\n  const rowDefs: string[] = [];\n  for (let r = 1; r <= totalRows; r++) {\n    if (r === headerRow || r === lbHeaderRow) {\n      rowDefs.push(\"auto\");\n    } else if (r > ubMaxRow && r < lbHeaderRow) {\n      // Gap rows\n      rowDefs.push(\"var(--bracket-match-gap, 1rem)\");\n    } else {\n      rowDefs.push(\n        \"calc(var(--bracket-match-height, calc(3.25rem + 1px)) / 2 + var(--bracket-match-gap, 1rem) / 2)\",\n      );\n    }\n  }\n\n  // --- GF vertical positioning ---\n  const ubFinalPos = ubRows[ubRows.length - 1]?.[0];\n  const lbFinalPos = lbRows[lbRows.length - 1]?.[0];\n\n  const gfRowStart = ubFinalPos ? ubFinalPos.topRow : ubStartRow;\n  const gfRowEnd = lbFinalPos ? lbFinalPos.botRow + 1 : lbStartRow + 2;\n\n  return (\n    <div\n      className={cn(\"inline-grid overflow-x-auto\", \"rounded-lg p-6\", \"bg-background\", className)}\n      style={{\n        gridTemplateColumns: colDefs.join(\" \"),\n        gridTemplateRows: rowDefs.join(\" \"),\n      }}\n    >\n      {/* === UB Round Headers === */}\n      {upper.map((round, i) => (\n        <div\n          key={`ub-header-${round.name}`}\n          className=\"text-xs font-medium text-muted-foreground mb-1 whitespace-nowrap flex items-end justify-center\"\n          style={{\n            gridRow: headerRow,\n            gridColumn: ubMatchCols[i]!,\n          }}\n        >\n          {round.name}\n        </div>\n      ))}\n\n      {/* === UB Matches === */}\n      {upper.map((round, ri) =>\n        round.matches.map((match, mi) => {\n          const pos = ubRows[ri]![mi]!;\n          return (\n            <GridMatch\n              key={match.id}\n              match={match}\n              topRow={pos.topRow}\n              col={ubMatchCols[ri]!}\n              onMatchClick={onMatchClick}\n            />\n          );\n        }),\n      )}\n\n      {/* === UB Connectors === */}\n      {ubConnCols.map((col, i) => {\n        const prevRound = ubRows[i]!;\n        const nextRound = ubRows[i + 1]!;\n        const span = ubConnSpans[i]!;\n\n        return (\n          <MergeConnectors\n            key={`ub-conn-${i}`}\n            prevPositions={prevRound}\n            nextPositions={nextRound}\n            gridCol={col}\n            gridColSpan={span}\n            style={connectorStyle}\n          />\n        );\n      })}\n\n      {/* === LB Round Headers === */}\n      {lower.map((round, i) => (\n        <div\n          key={`lb-header-${round.name}`}\n          className=\"text-xs font-medium text-muted-foreground mb-1 whitespace-nowrap flex items-end justify-center\"\n          style={{\n            gridRow: lbHeaderRow,\n            gridColumn: lbMatchCols[i]!,\n          }}\n        >\n          {round.name}\n        </div>\n      ))}\n\n      {/* === LB Matches === */}\n      {lower.map((round, ri) =>\n        round.matches.map((match, mi) => {\n          const pos = lbRows[ri]![mi]!;\n          return (\n            <GridMatch\n              key={match.id}\n              match={match}\n              topRow={pos.topRow}\n              col={lbMatchCols[ri]!}\n              onMatchClick={onMatchClick}\n            />\n          );\n        }),\n      )}\n\n      {/* === LB Connectors === */}\n      {lbConnCols.map((col, i) => {\n        const prevRound = lbRows[i]!;\n        const nextRound = lbRows[i + 1]!;\n        const connType = lbConnTypes[i]!;\n        if (connType === \"merge\") {\n          return (\n            <MergeConnectors\n              key={`lb-conn-${i}`}\n              prevPositions={prevRound}\n              nextPositions={nextRound}\n              gridCol={col}\n              gridColSpan={1}\n              style={connectorStyle}\n            />\n          );\n        }\n        return (\n          <StraightConnectors\n            key={`lb-conn-${i}`}\n            positions={prevRound}\n            gridCol={col}\n            style={connectorStyle}\n          />\n        );\n      })}\n\n      {/* === Grand Final === */}\n      {grandFinal && ubFinalPos && lbFinalPos && (\n        <>\n          {/* GF header */}\n          <div\n            className=\"text-xs font-medium text-muted-foreground mb-1 whitespace-nowrap flex items-end justify-center\"\n            style={{\n              gridRow: headerRow,\n              gridColumn: gfMatchCol,\n            }}\n          >\n            Grand Final\n          </div>\n\n          {/* GF connector */}\n          <GrandFinalConnector\n            ubFinalPos={ubFinalPos}\n            lbFinalPos={lbFinalPos}\n            gridCol={gfConnCol}\n          />\n\n          {/* GF match card */}\n          <div\n            className=\"flex items-center\"\n            style={{\n              gridRow: `${gfRowStart} / ${gfRowEnd}`,\n              gridColumn: gfMatchCol,\n              alignSelf: \"center\",\n            }}\n          >\n            <div\n              style={{\n                height: \"var(--bracket-match-height, calc(3.25rem + 1px))\",\n              }}\n            >\n              <MatchCard match={grandFinal} onMatchClick={onMatchClick} className=\"h-full\" />\n            </div>\n          </div>\n        </>\n      )}\n    </div>\n  );\n}\n\nfunction GridMatch({\n  match,\n  topRow,\n  col,\n  onMatchClick,\n}: {\n  match: Match;\n  topRow: number;\n  col: number;\n  onMatchClick?: (match: Match) => void;\n}) {\n  return (\n    <div\n      className=\"flex items-center\"\n      style={{\n        gridRow: `${topRow} / ${topRow + 2}`,\n        gridColumn: col,\n      }}\n    >\n      <div\n        style={{\n          height: \"var(--bracket-match-height, calc(3.25rem + 1px))\",\n          width: \"100%\",\n        }}\n      >\n        <MatchCard match={match} onMatchClick={onMatchClick} className=\"h-full\" />\n      </div>\n    </div>\n  );\n}\n\nfunction MergeConnectors({\n  prevPositions,\n  nextPositions,\n  gridCol,\n  gridColSpan,\n  style = \"default\",\n}: {\n  prevPositions: MatchPos[];\n  nextPositions: MatchPos[];\n  gridCol: number;\n  gridColSpan: number;\n  style?: \"default\" | \"simple\";\n}) {\n  const elements: React.ReactElement[] = [];\n\n  for (let i = 0; i < nextPositions.length; i++) {\n    const topFeeder = prevPositions[i * 2]!;\n    const botFeeder = prevPositions[i * 2 + 1]!;\n\n    const startRow = topFeeder.topRow;\n    const endRow = botFeeder.botRow + 1;\n\n    if (style === \"simple\") {\n      // Compute feeder center positions as percentages of the cell height.\n      // Each feeder is 1 grid-row from the edge; the cell spans numRows rows.\n      const numRows = endRow - startRow;\n      const topPct = (1 / numRows) * 100;\n      const botPct = ((numRows - 1) / numRows) * 100;\n\n      elements.push(\n        <div\n          key={`merge-${i}`}\n          className=\"relative\"\n          style={{\n            gridRow: `${startRow} / ${endRow}`,\n            gridColumn: gridColSpan > 1 ? `${gridCol} / ${gridCol + gridColSpan}` : gridCol,\n          }}\n        >\n          {/* Top Path: Source(topPct%) → Target Top Team Row (50% - mh/4) */}\n          <div\n            className=\"absolute border-t border-r border-border\"\n            style={{\n              top: `${topPct}%`,\n              right: \"50%\",\n              width: \"50%\",\n              height: `calc(${50 - topPct}% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25)`,\n            }}\n          />\n          <div\n            className=\"absolute border-b border-border\"\n            style={{\n              top: \"calc(50% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25)\",\n              left: \"50%\",\n              width: \"50%\",\n            }}\n          />\n\n          {/* Bot Path: Source(botPct%) → Target Bot Team Row (50% + mh/4) */}\n          <div\n            className=\"absolute border-b border-r border-border\"\n            style={{\n              bottom: `${100 - botPct}%`,\n              right: \"50%\",\n              width: \"50%\",\n              height: `calc(${botPct - 50}% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25)`,\n            }}\n          />\n          <div\n            className=\"absolute border-b border-border\"\n            style={{\n              bottom: \"calc(50% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25)\",\n              left: \"50%\",\n              width: \"50%\",\n            }}\n          />\n        </div>\n      );\n    } else {\n      // Default SVG style\n      elements.push(\n        <div\n          key={`merge-${i}`}\n          className=\"relative\"\n          style={{\n            gridRow: `${startRow} / ${endRow}`,\n            gridColumn: gridColSpan > 1 ? `${gridCol} / ${gridCol + gridColSpan}` : gridCol,\n          }}\n        >\n          <svg\n            className=\"w-full h-full text-border\"\n            preserveAspectRatio=\"none\"\n            viewBox=\"0 0 100 100\"\n            aria-hidden\n          >\n            <path\n              d={[\"M 0 25 H 50\", \"M 0 75 H 50\", \"M 50 25 V 75\", \"M 50 50 H 100\"].join(\" \")}\n              fill=\"none\"\n              stroke=\"currentColor\"\n              strokeWidth={1.5}\n              vectorEffect=\"non-scaling-stroke\"\n            />\n          </svg>\n        </div>,\n      );\n    }\n  }\n\n  return <>{elements}</>;\n}\n\nfunction StraightConnectors({\n  positions,\n  gridCol,\n  style = \"default\",\n}: {\n  positions: MatchPos[];\n  gridCol: number;\n  style?: \"default\" | \"simple\";\n}) {\n  return (\n    <>\n      {positions.map((pos, i) => (\n        <div\n          key={`straight-${i}`}\n          className=\"relative\"\n          style={{\n            gridRow: `${pos.topRow} / ${pos.botRow + 1}`,\n            gridColumn: gridCol,\n          }}\n        >\n          {style === \"simple\" ? (\n            <>\n              {/* Half stub: UB drop entry at top team row */}\n              <div\n                className=\"absolute border-b border-border\"\n                style={{\n                  top: \"calc(50% - var(--bracket-match-height) * 0.25)\",\n                  left: \"50%\",\n                  width: \"50%\",\n                }}\n              />\n\n              {/* Main Path: Source (Left, 50%) -> Down -> Target Bottom Team Row (LB carry) */}\n              <div\n                className=\"absolute border-t border-r border-border\"\n                style={{\n                  top: \"50%\",\n                  left: \"0\",\n                  width: \"50%\",\n                  height: \"calc(var(--bracket-match-height) * 0.25)\",\n                }}\n              />\n              <div\n                className=\"absolute border-t border-border\"\n                style={{\n                  top: \"calc(50% + var(--bracket-match-height) * 0.25)\",\n                  left: \"50%\",\n                  width: \"50%\",\n                }}\n              />\n            </>\n          ) : (\n            <svg\n              className=\"w-full h-full text-border\"\n              preserveAspectRatio=\"none\"\n              viewBox=\"0 0 100 100\"\n              aria-hidden\n            >\n              <path\n                d=\"M 0 50 H 100\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                strokeWidth={1.5}\n                vectorEffect=\"non-scaling-stroke\"\n              />\n            </svg>\n          )}\n        </div>\n      ))}\n    </>\n  );\n}\n\nfunction GrandFinalConnector({\n  ubFinalPos,\n  lbFinalPos,\n  gridCol,\n}: {\n  ubFinalPos: MatchPos;\n  lbFinalPos: MatchPos;\n  gridCol: number;\n}) {\n  const startRow = ubFinalPos.topRow;\n  const endRow = lbFinalPos.botRow + 1;\n\n  return (\n    <div\n      className=\"relative\"\n      style={{\n        gridRow: `${startRow} / ${endRow}`,\n        gridColumn: gridCol,\n      }}\n    >\n      <svg\n        className=\"w-full h-full text-border\"\n        preserveAspectRatio=\"none\"\n        viewBox=\"0 0 100 100\"\n        aria-hidden\n      >\n        {/* Upper arm from UB final center */}\n        <path\n          d={`M 0 ${(100 * (ubFinalPos.topRow + 1 - startRow)) / (endRow - startRow)} H 50`}\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth={1.5}\n          vectorEffect=\"non-scaling-stroke\"\n        />\n        {/* Lower arm from LB final center */}\n        <path\n          d={`M 0 ${(100 * (lbFinalPos.topRow + 1 - startRow)) / (endRow - startRow)} H 50`}\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth={1.5}\n          vectorEffect=\"non-scaling-stroke\"\n        />\n        {/* Vertical bar */}\n        <path\n          d={`M 50 ${(100 * (ubFinalPos.topRow + 1 - startRow)) / (endRow - startRow)} V ${(100 * (lbFinalPos.topRow + 1 - startRow)) / (endRow - startRow)}`}\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth={1.5}\n          vectorEffect=\"non-scaling-stroke\"\n        />\n        {/* Output to GF */}\n        <path\n          d=\"M 50 50 H 100\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth={1.5}\n          vectorEffect=\"non-scaling-stroke\"\n        />\n      </svg>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/bracketcore/match-card.tsx",
      "content": "import type { Match, MatchTeam } from \"./bracket-types\";\nimport { cn } from \"./cn\";\n\nconst WEEKDAYS = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\nconst MONTHS = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\nfunction formatSchedule(value: Date | string): { time: string; day: string } {\n  const date = value instanceof Date ? value : new Date(value);\n  if (Number.isNaN(date.getTime())) return { time: \"\", day: String(value) };\n\n  const now = new Date();\n  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n  const target = new Date(date.getFullYear(), date.getMonth(), date.getDate());\n  const diffDays = Math.round((target.getTime() - today.getTime()) / 86_400_000);\n\n  const time = `${String(date.getHours()).padStart(2, \"0\")}:${String(date.getMinutes()).padStart(2, \"0\")}`;\n\n  if (diffDays === 0) return { time, day: \"Today\" };\n  if (diffDays === 1) return { time, day: \"Tomorrow\" };\n  if (diffDays > 1 && diffDays < 7) return { time, day: WEEKDAYS[date.getDay()]! };\n  return { time, day: `${MONTHS[date.getMonth()]} ${date.getDate()}` };\n}\n\nexport interface MatchCardProps {\n  match: Match;\n  className?: string;\n  onMatchClick?: (match: Match) => void;\n}\n\nfunction TeamRow({\n  entry,\n  isLive,\n  isLeading,\n}: {\n  entry: MatchTeam;\n  isLive?: boolean;\n  isLeading?: boolean;\n}) {\n  const isWinner = entry.isWinner === true;\n  const isLoser = entry.isWinner === false;\n\n  return (\n    <div\n      className={cn(\n        \"flex items-center gap-2 px-2.5 py-1.5\",\n        \"border-l-3\",\n        isWinner && \"border-l-emerald-500\",\n        isLoser && \"border-l-destructive\",\n        !isWinner && !isLoser && \"border-l-transparent\",\n      )}\n    >\n      <div className=\"flex items-center gap-2 min-w-0 flex-1\">\n        {entry.team?.logo && (\n          <img\n            src={entry.team.logo}\n            alt={entry.team.name}\n            className=\"h-4 w-4 shrink-0 object-contain\"\n          />\n        )}\n        <span\n          className={cn(\n            \"truncate text-sm leading-none\",\n            isWinner && \"font-semibold text-card-foreground\",\n            isLoser && \"text-card-foreground/40\",\n            !isWinner && !isLoser && \"text-card-foreground\",\n            !entry.team && \"text-muted-foreground\",\n          )}\n        >\n          {entry.team?.name ?? \"TBD\"}\n        </span>\n      </div>\n      <span\n        className={cn(\n          \"text-sm tabular-nums shrink-0 leading-none font-medium\",\n          isLive && isLeading && \"text-emerald-500\",\n          isLive && isLeading === false && \"text-destructive\",\n          !isLive && isWinner && \"text-card-foreground\",\n          !isLive && isLoser && \"text-card-foreground/40\",\n        )}\n      >\n        {entry.score}\n      </span>\n    </div>\n  );\n}\n\nexport function MatchCard({ match, className, onMatchClick }: MatchCardProps) {\n  const bestOfLabel = match.bestOf ? `BO${match.bestOf}` : undefined;\n  const isLive = match.status === \"live\";\n  const isCompleted = match.status === \"completed\";\n  const hasHeader = !isCompleted && (isLive || match.scheduledAt || bestOfLabel);\n\n  return (\n    <div\n      className={cn(\n        \"w-(--bracket-match-width,11rem) rounded-sm shadow-sm\",\n        \"border-border\",\n        \"bg-card\",\n        \"text-card-foreground\",\n        \"shadow-sm overflow-hidden\",\n        isLive && \"border-destructive border\",\n        onMatchClick && \"cursor-pointer hover:border-primary/50 transition-colors\",\n        className,\n      )}\n      onClick={onMatchClick ? () => onMatchClick(match) : undefined}\n    >\n      {hasHeader && (\n        <div\n          className={`flex items-center justify-between px-2.5 py-1 text-xs text-muted-foreground bg-muted ${isLive && \"text-primary bg-destructive!\"}`}\n        >\n          <span className=\"flex items-center gap-1.5\">\n            {isLive && (\n              <>\n                <span className=\"relative flex h-2 w-2\">\n                  <span className=\"absolute inline-flex h-full w-full animate-ping rounded-full bg-primary opacity-75\" />\n                  <span className=\"relative inline-flex h-2 w-2 rounded-full bg-primary\" />\n                </span>\n                <span className=\"font-semibold uppercase\">Live</span>\n              </>\n            )}\n            {!isLive &&\n              match.scheduledAt &&\n              (() => {\n                const schedule = formatSchedule(match.scheduledAt!);\n                return (\n                  <span className=\"flex items-center gap-1\">\n                    <span className=\"font-bold text-[10px] mt-[1px]\">{schedule.time}</span>\n                    <span>{schedule.day}</span>\n                  </span>\n                );\n              })()}\n            {!isLive && !match.scheduledAt && <span>Unscheduled</span>}\n          </span>\n          {bestOfLabel && (\n            <span className={`ml-auto ${isLive && \"font-semibold\"}`}>{bestOfLabel}</span>\n          )}\n        </div>\n      )}\n      <TeamRow\n        entry={match.teams[0]}\n        isLive={isLive}\n        isLeading={\n          isLive\n            ? match.teams[0].score > match.teams[1].score\n              ? true\n              : match.teams[0].score < match.teams[1].score\n                ? false\n                : undefined\n            : undefined\n        }\n      />\n      <div className=\"border-t border-border\" />\n      <TeamRow\n        entry={match.teams[1]}\n        isLive={isLive}\n        isLeading={\n          isLive\n            ? match.teams[1].score > match.teams[0].score\n              ? true\n              : match.teams[1].score < match.teams[0].score\n                ? false\n                : undefined\n            : undefined\n        }\n      />\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/bracketcore/bracket-types.ts",
      "content": "export interface Team {\n  id: string;\n  name: string;\n  logo?: string;\n  seed?: number;\n}\n\nexport interface MatchTeam {\n  team: Team | null;\n  score: number;\n  isWinner?: boolean;\n}\n\nexport interface Match {\n  id: string;\n  round: number;\n  position: number;\n  bestOf?: number;\n  scheduledAt?: Date | string;\n  status?: MatchStatus;\n  teams: [MatchTeam, MatchTeam];\n}\n\nexport type MatchStatus = \"upcoming\" | \"live\" | \"completed\";\n\nexport interface Round {\n  name: string;\n  matches: Match[];\n}\n\nexport interface SingleEliminationBracket {\n  type: \"single-elimination\";\n  rounds: Round[];\n}\n\nexport interface DoubleEliminationBracket {\n  type: \"double-elimination\";\n  upper: Round[];\n  lower: Round[];\n  grandFinal?: Match;\n}\n\nexport interface SwissStanding {\n  team: Team;\n  wins: number;\n  losses: number;\n  tiebreaker?: number;\n  status?: \"advancing\" | \"eliminated\" | \"pending\";\n}\n\nexport interface SwissRound {\n  name: string;\n  record?: string;\n  matches: Match[];\n}\n\nexport interface SwissBracket {\n  type: \"swiss\";\n  rounds: SwissRound[];\n  standings: SwissStanding[];\n  winsToAdvance: number;\n  lossesToEliminate: number;\n}\n\nexport interface GroupStanding {\n  team: Team;\n  wins: number;\n  losses: number;\n  draws: number;\n  points: number;\n  differential: number;\n}\n\nexport interface Group {\n  name: string;\n  teams: Team[];\n  matches: Match[];\n  standings: GroupStanding[];\n}\n\nexport interface GroupStageBracket {\n  type: \"group-stage\";\n  groups: Group[];\n}\n\nexport type Bracket =\n  | SingleEliminationBracket\n  | DoubleEliminationBracket\n  | SwissBracket\n  | GroupStageBracket;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/bracketcore/cn.ts",
      "content": "import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:component"
}