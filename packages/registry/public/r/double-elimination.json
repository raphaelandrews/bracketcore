{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "double-elimination",
  "title": "Double Elimination",
  "description": "A double elimination bracket using CSS Grid for precise alignment.",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "match-card"
  ],
  "files": [
    {
      "path": "registry/bracketcore/double-elimination.tsx",
      "content": "import type { DoubleEliminationBracket, Match, Round } from \"./bracket-types\";\nimport { MatchCard } from \"./match-card\";\nimport { cn } from \"./cn\";\n\nexport interface DoubleEliminationProps {\n  bracket: DoubleEliminationBracket;\n  className?: string;\n  onMatchClick?: (match: Match) => void;\n  /**\n   * The LB round index that the first UB round should align with.\n   * Useful when LB starts \"earlier\" (has preliminary rounds) than UB.\n   * Default: 0.\n   */\n  ubAlignToLBRound?: number;\n  connectorStyle?: \"default\" | \"simple\";\n}\n\n// Each match occupies 2 grid rows (one per team row).\n// Row computation builds bottom-up: round 1 matches are evenly spaced,\n// subsequent rounds are centered between their two feeder matches.\n\ninterface MatchPos {\n  topRow: number;\n  botRow: number;\n}\n\nfunction computeBracketRows(\n  rounds: Round[],\n  startRow: number,\n  connectorTypes: Array<\"merge\" | \"straight\">,\n): MatchPos[][] {\n  const result: MatchPos[][] = [];\n\n  // Round 1: matches stacked sequentially\n  const r0: MatchPos[] = [];\n  for (let i = 0; i < rounds[0]!.matches.length; i++) {\n    const top = startRow + i * 2;\n    r0.push({ topRow: top, botRow: top + 1 });\n  }\n  result.push(r0);\n\n  // Subsequent rounds\n  for (let r = 1; r < rounds.length; r++) {\n    const prev = result[r - 1]!;\n    const curr: MatchPos[] = [];\n    const connType = connectorTypes[r - 1];\n\n    if (connType === \"merge\") {\n      // 2â†’1: center between pairs\n      for (let i = 0; i < rounds[r]!.matches.length; i++) {\n        const feederA = prev[i * 2]!;\n        const feederB = prev[i * 2 + 1]!;\n        const center = Math.floor((feederA.topRow + feederB.botRow) / 2);\n        curr.push({ topRow: center, botRow: center + 1 });\n      }\n    } else {\n      // straight: same rows as previous round\n      for (let i = 0; i < rounds[r]!.matches.length; i++) {\n        curr.push({ ...prev[i]! });\n      }\n    }\n\n    result.push(curr);\n  }\n\n  return result;\n}\n\nfunction computeConnectorTypes(rounds: Round[]): Array<\"merge\" | \"straight\"> {\n  const types: Array<\"merge\" | \"straight\"> = [];\n  for (let i = 0; i < rounds.length - 1; i++) {\n    types.push(rounds[i + 1]!.matches.length < rounds[i]!.matches.length ? \"merge\" : \"straight\");\n  }\n  return types;\n}\n\nexport function DoubleElimination({\n  bracket,\n  className,\n  onMatchClick,\n  ubAlignToLBRound = 0,\n  connectorStyle = \"default\",\n}: DoubleEliminationProps) {\n  const { upper, lower, grandFinal } = bracket;\n\n  // LB dictates the specific columns because it has more rounds (usually).\n  // LB Rounds: 0, 1, 2, ...\n  // Grid Columns:\n  // Col 0: LB R0 Match\n  // Col 1: LB R0->R1 Connector\n  // Col 2: LB R1 Match\n  // Col 3: LB R1->R2 Connector\n  // Grid Col for LB Round i = i * 2 + 1 (1-based grid)\n\n  const getLBCol = (rIdx: number) => 1 + rIdx * 2;\n\n  // UB Alignment:\n  // UB R0 aligns with LB R0 -> Col 1.\n  // UB Final (last round) aligns with LB Final (last round).\n  // UB Intermediate rounds are interpolated.\n\n  const ubCount = upper.length;\n  const lbCount = lower.length;\n\n  // Function to map UB round index to Grid Column\n  // A Drop Round is LB Round 0, plus any subsequent round where match count >= previous round match count\n  const lbDropRoundIndices = [0];\n  for (let i = 0; i < lbCount - 1; i++) {\n    const currCount = lower[i]!.matches.length;\n    const nextCount = lower[i + 1]!.matches.length;\n    if (nextCount >= currCount) {\n      lbDropRoundIndices.push(i + 1);\n    }\n  }\n\n  const getUBCol = (rIdx: number) => {\n    // Determine the sequence of LB drop rounds map to.\n    // Look for the first drop round index that is >= ubAlignToLBRound.\n    // UB Round 0 maps to that drop round, UB Round 1 to the next, etc.\n    const startDropIdx = lbDropRoundIndices.findIndex((idx) => idx >= ubAlignToLBRound);\n\n    if (startDropIdx !== -1) {\n      const mappedIdx = startDropIdx + rIdx;\n      if (mappedIdx < lbDropRoundIndices.length) {\n        return getLBCol(lbDropRoundIndices[mappedIdx]!);\n      }\n\n      // Fallback: extrapolate from the last known drop round.\n      // Assume a standard cadence of 2 LB rounds per UB round thereafter.\n      const lastDrop = lbDropRoundIndices[lbDropRoundIndices.length - 1]!;\n      const extra = mappedIdx - (lbDropRoundIndices.length - 1);\n      return getLBCol(lastDrop + extra * 2);\n    }\n\n    // Fallback: If no drop round satisfies the alignment (unlikely unless align is huge),\n    // simple linear mapping.\n    return getLBCol(ubAlignToLBRound + rIdx * 2);\n  };\n\n  const ubMatchCols: number[] = [];\n  const ubConnCols: number[] = []; // Column where the connector STARTS\n  const ubConnSpans: number[] = [];\n\n  for (let i = 0; i < ubCount; i++) {\n    ubMatchCols.push(getUBCol(i));\n    if (i < ubCount - 1) {\n      // Connector exists between current Round and Next Round\n      const startCol = getUBCol(i) + 1; // Start right after current match\n      const endCol = getUBCol(i + 1); // End right before next match\n      ubConnCols.push(startCol);\n      ubConnSpans.push(endCol - startCol);\n    }\n  }\n\n  const lbMatchCols: number[] = [];\n  const lbConnCols: number[] = [];\n\n  for (let i = 0; i < lbCount; i++) {\n    lbMatchCols.push(getLBCol(i));\n    if (i < lbCount - 1) {\n      lbConnCols.push(getLBCol(i) + 1);\n    }\n  }\n\n  // Grand Final Column\n  const lastBracketCol = Math.max(\n    lbMatchCols[lbMatchCols.length - 1] ?? 0,\n    ubMatchCols[ubMatchCols.length - 1] ?? 0,\n  );\n\n  const gfConnCol = grandFinal ? lastBracketCol + 1 : 0;\n  const gfMatchCol = grandFinal ? lastBracketCol + 2 : 0;\n  const totalCols = grandFinal ? gfMatchCol : lastBracketCol;\n\n  // --- Connector types and Drop Round detection ---\n  // UB always matches\n  const lbConnTypes = computeConnectorTypes(lower);\n\n  // A Drop Round is one that was preceded by a \"straight\" connection.\n  // Matches in Drop Rounds are shifted up by 0.25H (accumulating).\n  const lbShiftMultiplier: number[] = [0];\n  for (let i = 1; i < lower.length; i++) {\n    const prevConn = lbConnTypes[i - 1];\n    const prevShift = lbShiftMultiplier[i - 1]!;\n    // If Drop Round (straight), step up by -0.25.\n    // If Merge Round, maintain previous shift.\n    lbShiftMultiplier.push(prevConn === \"straight\" ? prevShift - 0.25 : prevShift);\n  }\n\n  // --- Row computation ---\n  const headerRow = 1;\n  const ubStartRow = 2;\n  const ubRows = computeBracketRows(upper, ubStartRow, Array(upper.length - 1).fill(\"merge\"));\n\n  // Total rows used by UB\n  const ubMaxRow =\n    ubRows[0]!.length > 0 ? ubRows[0]![ubRows[0]!.length - 1]!.botRow : ubStartRow + 1;\n\n  const gapRows = 2;\n  const lbHeaderRow = ubMaxRow + gapRows + 1;\n  const lbStartRow = lbHeaderRow + 1;\n  const lbRows = computeBracketRows(lower, lbStartRow, lbConnTypes);\n\n  // Total rows used by LB\n  const lbMaxRow =\n    lbRows[0]!.length > 0 ? lbRows[0]![lbRows[0]!.length - 1]!.botRow : lbStartRow + 1;\n\n  const totalRows = lbMaxRow + 1;\n\n  // Build grid-template-columns\n  const colDefs: string[] = [];\n  for (let c = 1; c <= totalCols; c++) {\n    const isMatchCol = ubMatchCols.includes(c) || lbMatchCols.includes(c) || c === gfMatchCol;\n\n    if (isMatchCol) {\n      colDefs.push(\"var(--bracket-match-width, 11rem)\");\n    } else {\n      colDefs.push(\"var(--bracket-round-gap, 3rem)\");\n    }\n  }\n\n  // Build grid-template-rows\n  const rowDefs: string[] = [];\n  for (let r = 1; r <= totalRows; r++) {\n    if (r === headerRow || r === lbHeaderRow) {\n      rowDefs.push(\"auto\");\n    } else if (r > ubMaxRow && r < lbHeaderRow) {\n      // Gap rows\n      rowDefs.push(\"var(--bracket-match-gap, 1rem)\");\n    } else {\n      rowDefs.push(\n        \"calc(var(--bracket-match-height, calc(3.25rem + 1px)) / 2 + var(--bracket-match-gap, 1rem) / 2)\",\n      );\n    }\n  }\n\n  // --- GF vertical positioning ---\n  const ubFinalPos = ubRows[ubRows.length - 1]?.[0];\n  const lbFinalPos = lbRows[lbRows.length - 1]?.[0];\n\n  const gfRowStart = ubFinalPos ? ubFinalPos.topRow : ubStartRow;\n  const gfRowEnd = lbFinalPos ? lbFinalPos.botRow + 1 : lbStartRow + 2;\n\n  return (\n    <div\n      className={cn(\"inline-grid overflow-x-auto rounded-lg p-6\", className)}\n      style={{\n        gridTemplateColumns: colDefs.join(\" \"),\n        gridTemplateRows: rowDefs.join(\" \"),\n      }}\n    >\n      {/* === UB Round Headers === */}\n      {upper.map((round, i) => (\n        <div\n          key={`ub-header-${round.name}`}\n          className=\"text-xs font-medium text-muted-foreground mb-2 whitespace-nowrap flex items-end justify-center\"\n          style={{\n            gridRow: headerRow,\n            gridColumn: ubMatchCols[i]!,\n          }}\n        >\n          {round.name}\n        </div>\n      ))}\n\n      {/* === UB Matches === */}\n      {upper.map((round, ri) =>\n        round.matches.map((match, mi) => {\n          const pos = ubRows[ri]![mi]!;\n          return (\n            <GridMatch\n              key={match.id}\n              match={match}\n              topRow={pos.topRow}\n              col={ubMatchCols[ri]!}\n              onMatchClick={onMatchClick}\n            />\n          );\n        }),\n      )}\n\n      {/* === UB Connectors === */}\n      {ubConnCols.map((col, i) => {\n        const prevRound = ubRows[i]!;\n        const nextRound = ubRows[i + 1]!;\n        const span = ubConnSpans[i]!;\n\n        return (\n          <MergeConnectors\n            key={`ub-conn-${i}`}\n            prevPositions={prevRound}\n            nextPositions={nextRound}\n            gridCol={col}\n            gridColSpan={span}\n            style={connectorStyle}\n          />\n        );\n      })}\n\n      {/* === LB Round Headers === */}\n      {lower.map((round, i) => (\n        <div\n          key={`lb-header-${round.name}`}\n          className=\"text-xs font-medium text-muted-foreground mb-2 whitespace-nowrap flex items-end justify-center\"\n          style={{\n            gridRow: lbHeaderRow,\n            gridColumn: lbMatchCols[i]!,\n          }}\n        >\n          {round.name}\n        </div>\n      ))}\n\n      {/* === LB Matches === */}\n      {lower.map((round, ri) => {\n        const shiftMult = lbShiftMultiplier[ri] ?? 0;\n        return round.matches.map((match, mi) => {\n          const pos = lbRows[ri]![mi]!;\n          return (\n            <GridMatch\n              key={match.id}\n              match={match}\n              topRow={pos.topRow}\n              col={lbMatchCols[ri]!}\n              onMatchClick={onMatchClick}\n              shiftMultiplier={connectorStyle === \"simple\" ? shiftMult : 0}\n            />\n          );\n        });\n      })}\n\n      {/* === LB Connectors === */}\n      {lbConnCols.map((col, i) => {\n        const prevRound = lbRows[i]!;\n        const nextRound = lbRows[i + 1]!;\n        const connType = lbConnTypes[i]!;\n\n        const sourceShift = lbShiftMultiplier[i] ?? 0;\n        const targetShift = lbShiftMultiplier[i + 1] ?? 0;\n\n        if (connType === \"merge\") {\n          return (\n            <MergeConnectors\n              key={`lb-conn-${i}`}\n              prevPositions={prevRound}\n              nextPositions={nextRound}\n              gridCol={col}\n              gridColSpan={1}\n              style={connectorStyle}\n              sourceShift={sourceShift}\n              targetShift={targetShift}\n            />\n          );\n        }\n        return (\n          <StraightConnectors\n            key={`lb-conn-${i}`}\n            positions={prevRound}\n            gridCol={col}\n            style={connectorStyle}\n            sourceShift={sourceShift}\n            targetShift={targetShift}\n          />\n        );\n      })}\n\n      {/* === Grand Final === */}\n      {grandFinal && ubFinalPos && lbFinalPos && (\n        <>\n          {/* GF header */}\n          <div\n            className=\"text-xs font-medium text-muted-foreground mb-2 whitespace-nowrap flex items-end justify-center\"\n            style={{\n              gridRow: headerRow,\n              gridColumn: gfMatchCol,\n            }}\n          >\n            Grand Final\n          </div>\n\n          {/* GF connector */}\n          <GrandFinalConnector\n            ubFinalPos={ubFinalPos}\n            lbFinalPos={lbFinalPos}\n            gridCol={gfConnCol}\n            style={connectorStyle}\n            lbShiftMultiplier={\n              connectorStyle === \"simple\" ? (lbShiftMultiplier[lbCount - 1] ?? 0) : 0\n            }\n          />\n\n          {/* GF match card */}\n          <div\n            className=\"flex items-center\"\n            style={{\n              gridRow: `${gfRowStart} / ${gfRowEnd}`,\n              gridColumn: gfMatchCol,\n              alignSelf: \"center\",\n            }}\n          >\n            <div\n              style={{\n                height: \"var(--bracket-match-height, calc(3.25rem + 1px))\",\n              }}\n            >\n              <MatchCard match={grandFinal} onMatchClick={onMatchClick} className=\"h-full\" />\n            </div>\n          </div>\n        </>\n      )}\n    </div>\n  );\n}\n\nfunction GridMatch({\n  match,\n  topRow,\n  col,\n  onMatchClick,\n  shiftMultiplier = 0,\n}: {\n  match: Match;\n  topRow: number;\n  col: number;\n  onMatchClick?: (match: Match) => void;\n  shiftMultiplier?: number;\n}) {\n  return (\n    <div\n      className=\"flex items-center\"\n      style={{\n        gridRow: `${topRow} / ${topRow + 2}`,\n        gridColumn: col,\n        transform:\n          shiftMultiplier !== 0\n            ? `translateY(calc(var(--bracket-match-height, calc(3.25rem + 1px)) * ${shiftMultiplier}))`\n            : undefined,\n      }}\n    >\n      <div\n        style={{\n          height: \"var(--bracket-match-height, calc(3.25rem + 1px))\",\n          width: \"100%\",\n        }}\n      >\n        <MatchCard match={match} onMatchClick={onMatchClick} className=\"h-full\" />\n      </div>\n    </div>\n  );\n}\n\nfunction MergeConnectors({\n  prevPositions,\n  nextPositions,\n  gridCol,\n  gridColSpan,\n  style = \"default\",\n  sourceShift = 0,\n  targetShift = 0,\n}: {\n  prevPositions: MatchPos[];\n  nextPositions: MatchPos[];\n  gridCol: number;\n  gridColSpan: number;\n  style?: \"default\" | \"simple\";\n  sourceShift?: number;\n  targetShift?: number;\n}) {\n  const elements: React.ReactElement[] = [];\n\n  for (let i = 0; i < nextPositions.length; i++) {\n    const topFeeder = prevPositions[i * 2]!;\n    const botFeeder = prevPositions[i * 2 + 1]!;\n\n    const startRow = topFeeder.topRow;\n    const endRow = botFeeder.botRow + 1;\n\n    if (style === \"simple\") {\n      const topOffset = ` + var(--bracket-match-height, calc(3.25rem + 1px)) * ${sourceShift}`;\n      const botOffset = ` - var(--bracket-match-height, calc(3.25rem + 1px)) * ${sourceShift}`;\n\n      // Height Adjustments for Target Shift:\n      const topHeightAdj = ` + var(--bracket-match-height, calc(3.25rem + 1px)) * ${targetShift - sourceShift}`;\n      const botHeightAdj = ` + var(--bracket-match-height, calc(3.25rem + 1px)) * ${sourceShift - targetShift}`;\n\n      elements.push(\n        <div\n          key={`merge-${i}`}\n          className=\"relative\"\n          style={{\n            gridRow: `${startRow} / ${endRow}`,\n            gridColumn: gridColSpan > 1 ? `${gridCol} / ${gridCol + gridColSpan}` : gridCol,\n          }}\n        >\n          {/* Top Path: Feeder Center */}\n          <div\n            className=\"absolute border-border\"\n            style={{\n              borderTopWidth: \"1.5px\",\n              borderRightWidth: \"1.5px\",\n              top: `calc((var(--bracket-match-height, calc(3.25rem + 1px)) + var(--bracket-match-gap, 1rem)) / 2${topOffset})`,\n              right: \"50%\",\n              width: \"50%\",\n              height: `calc(50% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25 - (var(--bracket-match-height, calc(3.25rem + 1px)) + var(--bracket-match-gap, 1rem)) / 2${topHeightAdj})`,\n            }}\n          />\n          {/* Top Inbound Stub */}\n          <div\n            className=\"absolute border-border\"\n            style={{\n              borderBottomWidth: \"1.5px\",\n              top: `calc(50% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25 + var(--bracket-match-height, calc(3.25rem + 1px)) * ${targetShift})`,\n              left: \"50%\",\n              width: \"50%\",\n            }}\n          />\n\n          {/* Bot Path: Feeder Center */}\n          <div\n            className=\"absolute border-border\"\n            style={{\n              borderBottomWidth: \"1.5px\",\n              borderRightWidth: \"1.5px\",\n              bottom: `calc((var(--bracket-match-height, calc(3.25rem + 1px)) + var(--bracket-match-gap, 1rem)) / 2${botOffset})`,\n              right: \"50%\",\n              width: \"50%\",\n              height: `calc(50% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25 - (var(--bracket-match-height, calc(3.25rem + 1px)) + var(--bracket-match-gap, 1rem)) / 2${botHeightAdj})`,\n            }}\n          />\n          {/* Bot Inbound Stub */}\n          <div\n            className=\"absolute border-border\"\n            style={{\n              borderBottomWidth: \"1.5px\",\n              bottom: `calc(50% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25 - var(--bracket-match-height, calc(3.25rem + 1px)) * ${targetShift})`,\n              left: \"50%\",\n              width: \"50%\",\n            }}\n          />\n        </div>,\n      );\n    } else {\n      // Default SVG style\n      elements.push(\n        <div\n          key={`merge-${i}`}\n          className=\"relative\"\n          style={{\n            gridRow: `${startRow} / ${endRow}`,\n            gridColumn: gridColSpan > 1 ? `${gridCol} / ${gridCol + gridColSpan}` : gridCol,\n          }}\n        >\n          <svg\n            className=\"w-full h-full text-border\"\n            preserveAspectRatio=\"none\"\n            viewBox=\"0 0 100 100\"\n            aria-hidden\n          >\n            <path\n              d={[\"M 0 25 H 50\", \"M 0 75 H 50\", \"M 50 25 V 75\", \"M 50 50 H 100\"].join(\" \")}\n              fill=\"none\"\n              stroke=\"currentColor\"\n              strokeWidth={1.5}\n              vectorEffect=\"non-scaling-stroke\"\n            />\n          </svg>\n        </div>,\n      );\n    }\n  }\n\n  return <>{elements}</>;\n}\n\nfunction StraightConnectors({\n  positions,\n  gridCol,\n  style = \"default\",\n  sourceShift = 0,\n  targetShift = 0,\n}: {\n  positions: MatchPos[];\n  gridCol: number;\n  style?: \"default\" | \"simple\";\n  sourceShift?: number;\n  targetShift?: number;\n}) {\n  return (\n    <>\n      {positions.map((pos, i) => (\n        <div\n          key={`straight-${i}`}\n          className=\"relative\"\n          style={{\n            gridRow: `${pos.topRow} / ${pos.botRow + 1}`,\n            gridColumn: gridCol,\n          }}\n        >\n          {style === \"simple\" ? (\n            <>\n              {/* UB drop entry at top team row.\n                  Target Top Slot = Center_Visual - 0.25H.\n                  Center_Visual = Struct_Center + targetShift.\n                  Target Top Slot = Struct_Center + targetShift - 0.25.\n                  Struct_Center = 50% of cell.\n                  top = 50% + targetShift - 0.25.\n              */}\n              <div\n                className=\"absolute border-border\"\n                style={{\n                  borderBottomWidth: \"1.5px\",\n                  top: `calc(50% + var(--bracket-match-height, calc(3.25rem + 1px)) * ${targetShift - 0.25})`,\n                  left: \"50%\",\n                  width: \"50%\",\n                }}\n              />\n\n              {/* Main Path: Source (Left) -> Target (Right)\n                  Source Center = Struct + sourceShift.\n                  Target Bot Slot = Struct + targetShift + 0.25.\n                  Using sourceShift to draw the horizontal line.\n                  top = 50% + sourceShift.\n              */}\n              <div\n                className=\"absolute border-border\"\n                style={{\n                  borderBottomWidth: \"1.5px\",\n                  top: `calc(50% + var(--bracket-match-height, calc(3.25rem + 1px)) * ${sourceShift})`,\n                  left: \"0\",\n                  width: \"100%\",\n                }}\n              />\n            </>\n          ) : (\n            <svg\n              className=\"w-full h-full text-border\"\n              preserveAspectRatio=\"none\"\n              viewBox=\"0 0 100 100\"\n              aria-hidden\n            >\n              <path\n                d=\"M 0 50 H 100\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                strokeWidth={1.5}\n                vectorEffect=\"non-scaling-stroke\"\n              />\n            </svg>\n          )}\n        </div>\n      ))}\n    </>\n  );\n}\n\nfunction GrandFinalConnector({\n  ubFinalPos,\n  lbFinalPos,\n  gridCol,\n  style = \"default\",\n  lbShiftMultiplier = 0,\n}: {\n  ubFinalPos: MatchPos;\n  lbFinalPos: MatchPos;\n  gridCol: number;\n  style?: \"default\" | \"simple\";\n  lbShiftMultiplier?: number;\n}) {\n  const startRow = ubFinalPos.topRow;\n  const endRow = lbFinalPos.botRow + 1;\n\n  if (style === \"simple\") {\n    // Height of match+gap\n    // var(--bracket-match-height, calc(3.25rem + 1px))\n    // Lower Arm Bottom:\n    // LB Final is shifted by lbShiftMultiplier.\n    // Structural Center is default.\n    // Visual Center = Struct + Shift.\n    // Visual Bottom is \"Away from bottom\" -> `bottom` increases if move UP.\n    // Shift is negative (UP). So `bottom: calc(Def - Shift)`.\n    const botOffset = ` - var(--bracket-match-height, calc(3.25rem + 1px)) * ${lbShiftMultiplier}`;\n\n    return (\n      <div\n        className=\"relative\"\n        style={{\n          gridRow: `${startRow} / ${endRow}`,\n          gridColumn: gridCol,\n        }}\n      >\n        {/* Upper arm: UB Center -> Down-Right -> GF Top Slot */}\n        <div\n          className=\"absolute border-border\"\n          style={{\n            borderTopWidth: \"1.5px\",\n            borderRightWidth: \"1.5px\",\n            top: \"calc((var(--bracket-match-height, calc(3.25rem + 1px)) + var(--bracket-match-gap, 1rem)) / 2)\",\n            left: \"0\",\n            width: \"50%\",\n            height:\n              \"calc(50% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25 - (var(--bracket-match-height, calc(3.25rem + 1px)) + var(--bracket-match-gap, 1rem)) / 2)\",\n          }}\n        />\n        <div\n          className=\"absolute border-border\"\n          style={{\n            borderBottomWidth: \"1.5px\",\n            top: \"calc(50% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25)\",\n            left: \"50%\",\n            width: \"50%\",\n          }}\n        />\n\n        {/* Lower arm: LB Center -> Up-Right -> GF Bottom Slot. */}\n\n        <div\n          className=\"absolute border-border\"\n          style={{\n            borderBottomWidth: \"1.5px\",\n            borderRightWidth: \"1.5px\",\n            bottom: `calc((var(--bracket-match-height, calc(3.25rem + 1px)) + var(--bracket-match-gap, 1rem)) / 2${botOffset})`,\n            left: \"0\",\n            width: \"50%\",\n            height: `calc(50% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25 - (var(--bracket-match-height, calc(3.25rem + 1px)) + var(--bracket-match-gap, 1rem)) / 2${\" + var(--bracket-match-height, calc(3.25rem + 1px)) * \" + lbShiftMultiplier})`,\n          }}\n        />\n\n        <div\n          className=\"absolute border-border\"\n          style={{\n            borderBottomWidth: \"1.5px\",\n            bottom: \"calc(50% - var(--bracket-match-height, calc(3.25rem + 1px)) * 0.25)\",\n            left: \"50%\",\n            width: \"50%\",\n          }}\n        />\n      </div>\n    );\n  }\n\n  return (\n    <div\n      className=\"relative\"\n      style={{\n        gridRow: `${startRow} / ${endRow}`,\n        gridColumn: gridCol,\n      }}\n    >\n      <svg\n        className=\"w-full h-full text-border\"\n        preserveAspectRatio=\"none\"\n        viewBox=\"0 0 100 100\"\n        aria-hidden\n      >\n        {/* Upper arm from UB final center */}\n        <path\n          d={`M 0 ${(100 * (ubFinalPos.topRow + 1 - startRow)) / (endRow - startRow)} H 50`}\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth={1.5}\n          vectorEffect=\"non-scaling-stroke\"\n        />\n        {/* Lower arm from LB final center */}\n        <path\n          d={`M 0 ${(100 * (lbFinalPos.topRow + 1 - startRow)) / (endRow - startRow)} H 50`}\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth={1.5}\n          vectorEffect=\"non-scaling-stroke\"\n        />\n        {/* Vertical bar */}\n        <path\n          d={`M 50 ${(100 * (ubFinalPos.topRow + 1 - startRow)) / (endRow - startRow)} V ${(100 * (lbFinalPos.topRow + 1 - startRow)) / (endRow - startRow)}`}\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth={1.5}\n          vectorEffect=\"non-scaling-stroke\"\n        />\n        {/* Output to GF */}\n        <path\n          d=\"M 50 50 H 100\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth={1.5}\n          vectorEffect=\"non-scaling-stroke\"\n        />\n      </svg>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/bracketcore/match-card.tsx",
      "content": "import type { Match, MatchTeam } from \"./bracket-types\";\nimport { cn } from \"./cn\";\n\nconst WEEKDAYS = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\nconst MONTHS = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\nfunction formatSchedule(value: Date | string): { time: string; day: string } {\n  const date = value instanceof Date ? value : new Date(value);\n  if (Number.isNaN(date.getTime())) return { time: \"\", day: String(value) };\n\n  const now = new Date();\n  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n  const target = new Date(date.getFullYear(), date.getMonth(), date.getDate());\n  const diffDays = Math.round((target.getTime() - today.getTime()) / 86_400_000);\n\n  const time = `${String(date.getHours()).padStart(2, \"0\")}:${String(date.getMinutes()).padStart(2, \"0\")}`;\n\n  if (diffDays === 0) return { time, day: \"Today\" };\n  if (diffDays === 1) return { time, day: \"Tomorrow\" };\n  if (diffDays > 1 && diffDays < 7) return { time, day: WEEKDAYS[date.getDay()]! };\n  return { time, day: `${MONTHS[date.getMonth()]} ${date.getDate()}` };\n}\n\nexport interface MatchCardProps {\n  match: Match;\n  className?: string;\n  onMatchClick?: (match: Match) => void;\n  variant?: \"default\" | \"bordered\";\n}\n\nfunction TeamRow({\n  entry,\n  isLive,\n  isLeading,\n  variant = \"default\",\n}: {\n  entry: MatchTeam;\n  isLive?: boolean;\n  isLeading?: boolean;\n  variant?: \"default\" | \"bordered\";\n}) {\n  const isWinner = entry.isWinner === true;\n  const isLoser = entry.isWinner === false;\n  const showBorders = variant === \"bordered\";\n\n  return (\n    <div\n      className={cn(\n        \"flex items-center gap-2 px-2.5 py-1.5\",\n        showBorders && \"border-l-3\",\n        showBorders && isWinner && \"border-l-emerald-500\",\n        showBorders && isLoser && \"border-l-destructive\",\n        showBorders && !isWinner && !isLoser && \"border-l-transparent\",\n      )}\n    >\n      <div className=\"flex items-center gap-2 min-w-0 flex-1\">\n        {entry.team?.logo && (\n          <img\n            src={entry.team.logo}\n            alt={entry.team.name}\n            className=\"h-4 w-4 shrink-0 object-contain\"\n          />\n        )}\n        <span\n          className={cn(\n            \"truncate text-sm leading-none\",\n            isWinner && \"font-semibold text-card-foreground\",\n            isLoser && \"text-card-foreground/40\",\n            !isWinner && !isLoser && \"text-card-foreground\",\n            !entry.team && \"text-muted-foreground\",\n          )}\n        >\n          {entry.team?.name ?? \"TBD\"}\n        </span>\n      </div>\n      <span\n        className={cn(\n          \"text-sm tabular-nums shrink-0 leading-none font-medium\",\n          isLive && isLeading && \"text-emerald-500\",\n          isLive && isLeading === false && \"text-destructive\",\n          !isLive && isWinner && \"text-card-foreground\",\n          !isLive && isLoser && \"text-card-foreground/40\",\n        )}\n      >\n        {entry.score}\n      </span>\n    </div>\n  );\n}\n\nexport function MatchCard({ match, className, onMatchClick, variant = \"default\" }: MatchCardProps) {\n  const bestOfLabel = match.bestOf ? `BO${match.bestOf}` : undefined;\n  const isLive = match.status === \"live\";\n  const isCompleted = match.status === \"completed\";\n  const hasHeader = !isCompleted && (isLive || match.scheduledAt || bestOfLabel);\n\n  return (\n    <div\n      className={cn(\n        \"relative w-(--bracket-match-width,11rem) shadow-sm\",\n        hasHeader ? \"rounded-b-sm\" : \"rounded-sm\",\n        \"border-border\",\n        \"bg-card\",\n        \"text-card-foreground\",\n        \"shadow-sm overflow-visible\",\n        isLive && \"border-destructive border\",\n        onMatchClick && \"cursor-pointer hover:border-primary/50 transition-colors\",\n        className,\n      )}\n      onClick={onMatchClick ? () => onMatchClick(match) : undefined}\n    >\n      {hasHeader && (\n        <div\n          className={cn(\n            \"absolute bottom-full flex items-center justify-between px-2.5 py-1 text-xs rounded-t-sm\",\n            isLive ? \"-inset-x-px\" : \"inset-x-0\",\n            isLive ? \"text-primary bg-destructive\" : \"text-muted-foreground bg-muted\",\n          )}\n        >\n          <span className=\"flex items-center gap-1.5\">\n            {isLive && (\n              <>\n                <span className=\"relative flex h-2 w-2\">\n                  <span className=\"absolute inline-flex h-full w-full animate-ping rounded-full bg-primary opacity-75\" />\n                  <span className=\"relative inline-flex h-2 w-2 rounded-full bg-primary\" />\n                </span>\n                <span className=\"font-semibold uppercase\">Live</span>\n              </>\n            )}\n            {!isLive &&\n              match.scheduledAt &&\n              (() => {\n                const schedule = formatSchedule(match.scheduledAt!);\n                return (\n                  <span className=\"flex items-center gap-1\">\n                    <span className=\"font-bold text-[10px] mt-[1px]\">{schedule.time}</span>\n                    <span>{schedule.day}</span>\n                  </span>\n                );\n              })()}\n            {!isLive && !match.scheduledAt && <span>Unscheduled</span>}\n          </span>\n          {bestOfLabel && (\n            <span className={cn(\"ml-auto\", isLive && \"font-semibold\")}>{bestOfLabel}</span>\n          )}\n        </div>\n      )}\n      <TeamRow\n        entry={match.teams[0]}\n        isLive={isLive}\n        variant={isCompleted ? variant : \"default\"}\n        isLeading={\n          isLive\n            ? match.teams[0].score > match.teams[1].score\n              ? true\n              : match.teams[0].score < match.teams[1].score\n                ? false\n                : undefined\n            : undefined\n        }\n      />\n      <div className=\"border-t border-border\" />\n      <TeamRow\n        entry={match.teams[1]}\n        isLive={isLive}\n        variant={isCompleted ? variant : \"default\"}\n        isLeading={\n          isLive\n            ? match.teams[1].score > match.teams[0].score\n              ? true\n              : match.teams[1].score < match.teams[0].score\n                ? false\n                : undefined\n            : undefined\n        }\n      />\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/bracketcore/bracket-types.ts",
      "content": "export interface Team {\n  id: string;\n  name: string;\n  logo?: string;\n  seed?: number;\n}\n\nexport interface MatchTeam {\n  team: Team | null;\n  score: number;\n  isWinner?: boolean;\n}\n\nexport interface Match {\n  id: string;\n  round: number;\n  position: number;\n  bestOf?: number;\n  scheduledAt?: Date | string;\n  status?: MatchStatus;\n  teams: [MatchTeam, MatchTeam];\n}\n\nexport type MatchStatus = \"upcoming\" | \"live\" | \"completed\";\n\nexport interface Round {\n  name: string;\n  matches: Match[];\n}\n\nexport interface SingleEliminationBracket {\n  type: \"single-elimination\";\n  rounds: Round[];\n}\n\nexport interface DoubleEliminationBracket {\n  type: \"double-elimination\";\n  upper: Round[];\n  lower: Round[];\n  grandFinal?: Match;\n}\n\nexport interface SwissStanding {\n  team: Team;\n  wins: number;\n  losses: number;\n  tiebreaker?: number;\n  status?: \"advancing\" | \"eliminated\" | \"pending\";\n}\n\nexport interface SwissRound {\n  name: string;\n  record?: string;\n  matches: Match[];\n}\n\nexport interface SwissBracket {\n  type: \"swiss\";\n  rounds: SwissRound[];\n  standings: SwissStanding[];\n  winsToAdvance: number;\n  lossesToEliminate: number;\n}\n\nexport interface GroupStanding {\n  team: Team;\n  wins: number;\n  losses: number;\n  draws: number;\n  points: number;\n  differential: number;\n}\n\nexport interface Group {\n  name: string;\n  teams: Team[];\n  matches: Match[];\n  standings: GroupStanding[];\n}\n\nexport interface GroupStageBracket {\n  type: \"group-stage\";\n  groups: Group[];\n}\n\nexport type Bracket =\n  | SingleEliminationBracket\n  | DoubleEliminationBracket\n  | SwissBracket\n  | GroupStageBracket;\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/bracketcore/cn.ts",
      "content": "import { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:component"
}